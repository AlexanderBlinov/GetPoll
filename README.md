# GetPoll API

Суть API - работа с поллами (англ. *poll* - голосование), их добавление, удаление и, естественно, сам процесс голосования.

Это будет REST, так как из контекста задачи следует отсутствие каких либо специфических действий, которые было бы трудно представить в виде CRUD операций. Поэтому работать через представления ресурсов очень даже удобно.

API не будет RESTful, так как в нем не будет реализовано *self-descriptive messages*. Поддержка этого пункта займет слишком много времени, в то время как типов данных не так уж много, и будет гораздо быстрее заложить знание о них на клиенте, чем описывать свои vendor-типы. В качестве Content-Type будет использован простой application/json. Изначально были мысли о hal-json, так как в нем заложены стандарты пердставления ресурсов и гипермедиа. Но он показался давольно сложным для текущего варианта веб-сервиса. Хотя стоит отметить, что саму идею API можно гораздо больше развить, и, возможно, тогда было бы круто использовать HAL или свои vendor-типы.

## Интерфейс

1. `HTTP GET /polls` - выдает коллекцию поллов (реализует Read коллекции)

  Пример ответа

    ```
    {
      "data": [
        {
          "creationDateTime": "2016-10-20T19:36:11+03:00",  // Время создания полла по стандарту ISO 8601
          "links": {
            "self": "/polls/2"                              //  URL на конкретный ресурс полла
          },
          "name": "Best superhero movie 2016",              // Имя пола
          "totalVotes": 314                                 // Общее количество голосовавших
        },
        {
          "creationDateTime": "2016-10-20T18:05:47+03:00",
          "links": {
            "self": "/polls/1"
          },
          "name": "Who's gonna be next America president?",
          "totalVotes": 523
        }
      ],
      "links": {
        "next": "/polls?creationDateTime=2016-10-20T18%3A05%3A47%2B03%3A00",  // URL на следующие n поллов, добавленных до указанной даты
        "self": "/polls"
      }
    }
    ```

2. `HTTP GET /polls/{id}` - возвращает полл с указанным id (реализует Read ресурса)

  Пример ответа

    ```
    {
      "author": "geek_boy4000",                         // Username пользователя, создавшего полл
      "creationDateTime": "2016-10-20T18:05:47+03:00",  // Время создания в стандарте ISO 8601
      "description": "Which movie really nailed it?",   // Дополнительно описание
      "links": {
        "givenVote": "/polls/{id}/votes/{vote_id}",     // Гипермедия на голос, отданный пользователем
        "votes": "/polls/{id}/votes"                    // Гипермедия на коллекцию голосов
      },
      "name": "Best superhero movie 2016",              // Имя голосования
      "options": [                                      // Список вариантов ответа в голосовании
        {
          "id": 1,                                      // Идентификатор варианта ответа (достаточно просто порядкового номера)
          "name": "Bats vs Sups",                       // Имя варианта
          "votes": 123                                  // Число пользователей, выбравших этот ответ
        },
        {
          "id": 2,
          "name": "Civil War",
          "votes": 170
        },
        {
          "id": 3,
          "name": "X-Men",
          "votes": 121
        }
      ],
      "totalVotes": 314                                  // Общее число голосовавших
    }
    ```

3. `HTTP POST /polls` - создает полл и добавляет его в коллекцию polls (реализует Create ресурса)

  Пример запроса

    ```
    {
      "author": "trip_lover18",
      "creationDateTime": "2016-10-20T18:05:47+03:00",
      "description": "Please help me to decide what country I should visit next",
      "name": "What's the best place to visit?",
      "options": [
        {
          "id": 1,
          "name": "Norway"
        },
        {
          "id": 2,
          "name": "Iceland"
        }
      ]
    }
    ```

  В случае успеха возвращает `201 Created`, `Location: /polls/someId` в заголовке и представление созданного объекта в теле.

4. `HTTP DELETE /polls/{id}` - удаляет полл (реализует Delete рeсурса)

  В случае успеха вернет `204 No Content`.

  Если пользователь не является автором полла, вернется `403 Forbidden`.

5. `HTTP POST /polls/{id}/votes` - добавляет голос с указаным вариантом ответа (реализует Create рeсурса)

  Пример запроса

    ```
    {
      "optionId": 1,          // Номер выбранного варианта ответа
      "author": "marta2000"   // Username проголосовавшего пользователя
    }
    ```

  В случае успеха возвращает `201 Created`, `Location: /polls/{id}/votes/someId` в заголовке и представление созданного объекта в теле. Если пользователь уже добавлял свой голос в этом полле, то будет возвращен код `200 OK`.

6. `HTTP PUT /polls/{id}/votes/{vote_id}` - изменяет уже сделанный голос (реализует Update рeсурса)

  Пример запроса

    ```
    {
      "optionId": 2,
      "author": "marta2000"
    }
    ```
  В случае, когда пользователь не является автором, вернется `403 Forbidden`.

7. `HTTP DELETE /polls/{id}/votes/{vote_id}` - удаляет голос в конкретном полле (реализует Delete рeсурса)

  В случае успеха вернет `204 No Content`.

  В случае попытки удалить голос пользователем, который не является его автором, вернется `403 Forbidden`.


# CAP

Чаще всего неотемлемым требованием к распределенным систем является возможность работы каждой ноды независимо от состояние системы в целом. Поэтому partition tolerance мы однозначно берем, и речь пойдет о выборе между CP или AP системой.

## CP?

С одной стороны взять consistency для нашей системы выглядит весьма неплохо: запросы всех пользователей на чтение будут возвразать единственный и к тому же реальный результат. Это особенно важно в случае, когда пользователем является автор какого-либо голосавния, и он хочет подвести итоги этого голосования.

С консистентностью не будет ситуации, когда в случае распада системы на сервере, обрабатывающий запросы из США будет один результат, а на сервере в Европе совершенно другой. Ведь тогда то, какую информацию получит автор голосования, зависит от того, на какой сервер будет направлен его запрос на чтение.

Однако сохраняя консистентность на операцию чтения, мы, в случае распада, ограничиваем часть пользователей от возможности делать запросы на запись, т.е. от возмоности голосовать. Причем это может быть очень большая доля людей, голоса которых могли бы полностью изменить результат голосования.

Помимо недоступности голосовать, данное поведение чревато порчей репутации нашей системы у пользователей. Причем как у тех, кто просто голосует, так и у тех, кто эти голосования создает. Для первых нет смысла пользоваться системой, которая не может их голос учесть, а для вторых нет смысла в системе, которая не может гарантировать, что голоса всех желающих будут учтены.

## AP!

Из выше сказанного следует, что доступность операций записи важна не меньше, чем коситентность данных. Поэтому предлагается реализовать веб-сервис на базе eventually-consistent AP системы, и одним из решением таких систем является Riak.

Riak — это распределенная, масштабируемая, отказоустойчивая NoSQL система. Причина, по которой эта система обеспечивает высокую availability, заключается в отстутствии какого-либо управляющего узла, а способ хранения данных базируется на трех параметрах: N (количество реплик значения в хранилище), R (количество данных реплик необходимых для выполнения чтения) и W (количество данных реплик необходимых для выполнения записи).

Таким образом для каждой операции чтения и записи может быть задано допустимое количество недоступных узлов в кластере (N-R для чтения, N-W для записи). Кроме того, мы можем повысить доступность более важных для нас данных, повышая N при записи в хранилище.

Помимо этого, Riak имеет весьма эффективный механизм восстановления консистентности данных после распада системы на части. Riak использует алгоритм вектора времени, на основании которого он может определить какая версия документа является последней. Если же однозначно определить последнию версию не удалось и явно не указано использование какого-либо стандартного подхода, то Riak вызовет у клиента определенный sibling resolution.

Единственным нюансом является то, что у Riak нету официальной клиентской библиотеки для C++, лишь версия, разработанная коммьнити. Причем последний апдейт в этой версии был в 2014 году. Кроме относительной несвежести в библиотеке реализован коннекшн клиента лишь только к одной ноде Riak (https://github.com/ajtack/riak-cpp).
